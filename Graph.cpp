
// Давыдов, В.Г. Программирование и основы алгоритмизации. стр. 266
#include "stdafx.h"

/*
Файл Graph.cpp. 
Функции решения транспортной задачи: 
* шаг вперед из достигнутой вершины по заданному ребру; 
* прохождение пути от достигнутой вершины InterMediate, если 
он есть, до вершины finish; 
* поиск пути минимального веса в неориентированном взвешенном 
графе; 
* печать информации о наилучшем пути от start до finish. 
Используется в программном проекте для решения транспорт­
ной задачи (задачи коммивояжера). | 
Давыдов В.Г, Консольное приложение^ Visual C++ 6 
*/

// Включаемый файл программного проекта для решения транс­
// портной задачи (задачи коммивояжера) 
#include "GrHead.h" 
// Определения объектов с описателем класса хранения внешний. 
// Их объявление имеется в заголовочном файле проекта и 
// доступно в других файлах проекта 
int start; // Вершина - старт пути 
// Эти объекты определяем в данном месте^ чтобы при 
// взаимнорекурсивных вызовах функций PassWay( ) и 
// ForStep ( ) они не создавались заново 
GRAPH Gr; // Граф 
W *pMinWay; // Указатель на массив структур с 
// информацией о наилучшем пути из 
// вершины start в finish 
int finish, // Вершина - финиш пути 
one, // 1-я вершина текущей дуги 
two; // 2-я вершина текущей дуги 

///////////////////////////////////////////////////////////
// Шаг вперед по ребру с индексом IndArc из вершины topi в 
// вершину top2 
void ForStep ( 
	int top1, // Достигнутая вершина, из которой 
	// шагаем вперед 
	int IndArc, // Индекс ребра, по которому 
	// делается шаг вперед 
	int top2 )
	// Вершина на конце ребра 
{ 
	float NewDist; // Расстояние до top2 по пути через 
					// topi 
	NewDist = pMinWay[top1].SumDist + 
	Gr.pArc[IndArc].weight; 

	if( !pMinWay[top2]. exist ) 
	{ // Пока пути до top2 нет 
		pMinWay[top2].exist = 1; 
		pMinWay[top2].SumDist = NewDist; 
		pMinWay[top2].ref = top1; 
		PassWay(top2);
	} 
	else 
	{ // Путь до top2 уже существует 
		if( pMinWay[top2]. SumDist > NewDist ) 
		{ // Новый путь короче 
			pMinWay[top2].SumDist = NewDist;
			pMinWay[top2].ref = top1; 
			PassWay(top2) ; 
		} 
	}
	return;
} 

///////////////////////////////////////////////////////////
// Прохождение пути от достигнутой вершины InterMedlate, если 
// он есть г до вершины finish 
void PassWay ( 
	// Достигнутая вершина - отправная точка пути 
	int InterMediate ) 
{ 
	int k; // Индекс текущей дуги графа 
	if( InterMediate == finish ) 
	{ // ! ! ! Выход из рекурсии 
		return; 
	} 
	else 
	{ 
		// Перебор ребер графа 
		for( k = 0; k < Gr.NumArc; k++ ) 
		{ 
			one = Gr.pArc[ k ].first; 
			two = Gr.pArc[ k ].last; 
			// Определения направления шага по ребру и 
			// выполнение шага в найденном направлении 
			if( one == InterMediate ) 
			{ 
				ForStep( one, k, two ); 
			} 
			else if( two == InterMediate ) 
			{ 
				ForStep ( two, k, one ); 
			} 
		} 
		return; // !!! Альтернативный вариант выхода 
				// из рекурсии 
	} 
} 

///////////////////////////////////////////////////////////
// Поиск пути минимального веса в неориентированном 
// взвешенном графе 
void solution ( void ) 
{ 
	int j;  // Индекс вершины 
	// Начальная подготовка массива структур с информацией о 
	// наилучшем пути 
	for( j = 0; j < Gr.NumTop; j++ ) 
	{ 
		pMinWay[ j ].exist = 0; 
	} 
	pMinWay [ start ]. exist = 1; 
	pMinWay[ start ].SumDist = 0.0f; 
	pMinWay[ start ].ref = -1; 
	// Рекурсивное определение требуемого пути 
	PassWay( start ); 
	return; 
} 

///////////////////////////////////////////////////////////
// Печать информации о наилучшем пути от start до finish 
void OutRes ( 
	char *pFileOut, // Указатель на файл вывода 
	char *pMode ) // Указатель на режим вывода в файл 
{ 
FILE *pStrOut; // Указатель на структуру со 
// сведениями о файле результатов 
int TempTop, // Текуш,ая вершина пути 
	RetCode1; // Возвраш;аемое значение fclose ( ) 
	// Открытие файла вывода 
	fopen_s( &pStrOut, pFileOut, pMode); 
	if( pStrOut == NULL ) 
	{ 
		printf( "\n Ошибка 140. Файл %s для вывода не " 
		"открыт \n" , pFileOut ); 
		exit ( 140 ) ; 
	} 
	// Печать информации о найденном пути 
	if( !pMinWay[ finish ].exist ) 
	{ 
		printf ( 
			"\n Искомого пути не существует \n" ) ; 
	} 
	else 
	{ 
		// Печать оптимального пути 
		TempTop = finish; 
		fprintf( pStrOut, 
		"\n Вершина-финиш: %d, вершина - старт: %d " 
		"\n Значение минимального пути: %g \n", finish, 
			start, pMinWay[ finish ].SumDist ); 
		fprintf ( pStrOut, "\n Список вершин, образуюш:их" 
			" этот путь (от finish до start): \n" ); 
		while ( TempTop != -1 ) 
		{ 
			fprintf( pStrOut, " %4d ", TempTop ); 
			TempTop = pMinWay [TempTop].ref; 
		} 
	} 

	// Закрытие файла результатов 
	RetCode1 = fclose( pStrOut ) ; 
	if( RetCode1 == EOF ) 
	{ 
		printf( "\n Ошибка 150. Файл %s не закрыт \n", 
		pFileOut ) ; 
		exit ( 150 ) ; 
	} 
	// Освобождение динамической памяти 
	GrFreeDM( ) ; 
	return;
}